/*
Initialisation: 
 - groups: array of size n, initialized with -1.
- frontier: array initialized with all nodes with upper = 1.
 - next_frontier: empty. 
- group_id: initialized with 0 it will use to mark the node with the group ID it belongs to. 

The algorithm iterates over all nodes in the "frontier" array, assigns the group ID to each node in the frontier, 
and adds the destination nodes of these nodes to the "next_frontier" array.
To handle undirected graphs, if a node has already been visited in a previous iteration 
(i.e., it was in the "frontier" array in a previous iteration), the algorithm skips it to prioritize the first checking of each node. 
(If a node has already been visited in a previous iteration, the algorithm checks if it has not been assigned a group ID yet).
After all nodes in the current "frontier" array have been processed, the "frontier" array is switched with the "next_frontier" array, 
the "next_frontier" array is emptied, and the group_id is incremented by 1.
This process is repeated until there are no more nodes left to process.

*/

Input: GraphNodes[], Edge[], upper[]
Output: group[]

function parallelTopologicalSort(GraphNodes, upper, Edge):
	groups = array of size n, initialized with -1 // The group order of node i in the topological sorting of the graph
	frontier = array initialized with all nodes with upper = 1
	next_frontier = empty 
	group_id = initialized with 0 //  to mark the node with the group ID it belongs to. It will be incremented by 1 during the code (line 33)
	changed = boolean variable initialized with true 

	for i in range(n) parallel do
		if upper [i] == 1 then 
			add node (i) to the frontier // atomic add 
		end if 
	end for 

	while changed:
		changed = false
		for each node in frontier parallel do
			groups[node] = group_id //  for all nodes in the current frontier, mark them with the group ID they belong to.
			// for all the edges of the nodes at the current frontier, add the destination to be visited in the next_frontier
			for i in range(GraphNodes[node].no_of_edges) parallel do 
				dest_node = Edge[GraphNodes[node].starting + i]
				/*
				To handle undirected graph:
				If a node has already been visited in a previous iteration (i.e., it was in the frontier in a previous iteration), 
				the algorithm skips it to give priority to the first checking of each node.
				*/
				if groups[node] == -1 then 
					add dest_node to the next_frontier // atomic add
					changed = true // keep iterating until no further changes
				end if
			end for
		end for
		// once done switch frontier with next frontier, empty next frontier
		if not next_frontier.empty then 
			group_id +=1  // atomic increment 
			frontier = next_frontier
			next_frontier = empty 
		end if 
	
	return groups 

/* NOTE 

groups :

It is an array of size n that holds the group IDs of each node in the topological sort. Each element groups[i] contains the group ID of node i in the topological sort.

For example, if groups = [0, 1, 0, 2, 1], it means that node 0 and node 2 belong to group 0, node 1 and node 4 belong to group 1, and node 3 belongs to group 2. This is a valid topological sort that satisfies the constraints of the input graph. */
