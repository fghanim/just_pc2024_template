Input: GraphNodes[], Edge[], upper[]
Output: group[]

function parallelTopologicalSort(GraphNodes, upper, Edge):
	groups = array of size n, initialized with -1 // The group order of node i in the topological sorting of the graph
	frontier = array initialized with all nodes with upper = 1
	next_frontier = empty 
	group_id = initialized with 0 //  to mark the node with the group ID it belongs to. It will be incremented by 1 during the code (line 33)
	changed = boolean variable initialized with true 

	for i in range(n) parallel do
		if upper [i] == 1 then 
			add node (i) to the frontier // atomic add 
		end if 
	end for 

	while changed:
		changed = false
		for each node in frontier parallel do
			groups[node] = group_id //  for all nodes in the current frontier, mark them with the group ID they belong to.
			for i in range(GraphNodes[node].no_of_edges) parallel do 
				dest_node = Edge[GraphNodes[node].starting + i]
				GraphNodes[dest_node].no_of_edges -=1   // atomic decrement
				if GraphNodes[dest_node].no_of_edges == 0 then 
					// for all the edges of the nodes at the current frontier, add the destination to be visited in the next_frontier
					add dest_node to the next_frontier // atomic add 
					changed = true // keep iterating until no further changes
				end if
			end for
		end for
		// once done switch frontier with next frontier, empty next frontier
		if not next_frontier.empty then 
			group_id +=1  // atomic increment 
			frontier = next_frontier
			next_frontier = empty 
		end if 
	
	return groups 

/* NOTE 

groups :

It is an array of size n that holds the group IDs of each node in the topological sort. Each element groups[i] contains the group ID of node i in the topological sort.

For example, if groups = [0, 1, 0, 2, 1], it means that node 0 and node 2 belong to group 0, node 1 and node 4 belong to group 1, and node 3 belongs to group 2. This is a valid topological sort that satisfies the constraints of the input graph. */

